#include "RModel.h"

#include <QDir>
#include <QApplication>
#include <QMetaProperty>
#include <QTimer>
#include <QDateTime>

#include "RParameter.h"
#include "RConstant.h"
#include "RResponse.h"
#include "RLocation.h"
#include "RLocationResponse.h"
#include "RMainWindow.h"

#ifdef NETWORKS
#include "RNetworkModel.h"
#endif



RModel::RModel(QObject *parent, QString name)
    : RObject(parent, name)
{
    isOrchestratingModel = false;
    isAnalyzed = false;

    theProcess = 0;
    processFinishedAnalyzing = false;
}

RModel::~RModel()
{
    delete theProcess;
}



QList<QPair<double, QString> > RModel::getTriggerTimes(double startTime, double endTime)
{
    QList<QPair<double, QString> > times;

    return times;
}



void RModel::setObjectName(const QString &name)
{
    QString oldName = objectName();
    QObject *object = qobject_cast<QObject *>(this);
    object->setObjectName(name);

    // Renaming auto-generated responses
    QList<RResponse *> responseList = findChildren<RResponse *>();
    for (int i = 0; i < responseList.count(); i++) {
        if (responseList[i]->isAutoGenerated()) {
            QString responseName = responseList[i]->objectName();
            if (responseName.contains(oldName)) {
                QString newResponseName = responseName.replace(oldName, name);
                responseList[i]->setObjectName(newResponseName);
            }
        }
    }


    // Terje split the parameters into a separate area in the object's pane, hence that area must also be updated:
    RMainWindow *mainWindow = qobject_cast<RMainWindow *>(theDomain->parent());
}



QStringList RModel::getActionList()
{
    QStringList actionList;

    actionList << "&Run" << "Separator" << "&Help";

    return actionList;
}



void RModel::run()
{   
//    if (checkProperties() >= 0) {

        if (isOrchestratingModel) {

            //  START TIMER
            QDateTime startTime = QDateTime::currentDateTime();

            // TELL USER WE'RE STARTING
            if (theOutputLevel == RObject::Maximum) {
                qDebug() << "The analysis in" << this->objectName() << "started";
            }


            // KEEP GUI RESPONSIVE
            QCoreApplication::processEvents();


            // EVALUATE THE MODEL
            this->evaluateModel();


            // TELL USER WE'RE DONE
            QDateTime finishTime = QDateTime::currentDateTime();
            double numDays = startTime.daysTo(finishTime);
            double numMilliSecs = startTime.time().msecsTo(finishTime.time());
            double numSecs = numDays * 86400.0 + numMilliSecs / 1000.0;
            if (theOutputLevel == RObject::Maximum) {
                qDebug() << "The analysis in" << this->objectName() << "completed in" << numSecs << "seconds.";
            }


            // SET THE 'ANALYZED' FLAG
            isAnalyzed = true;
        }
        else {

            runAnalysis(theGradientType);
        }
//    }
}


bool RModel::contains(RParameter *value)
{
    if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
    }
    bool containsFlag = theAllParametersList.contains(value);

    if (!containsFlag) {
        // Also check if the input RConstants that carry responses from downstream models depend on the passed RParameter (value)
        QList<RConstant *> contList = getConstantList();
        for (int i = 0; i < contList.count(); i++) {
            QList<RParameter *> upstreamParameterList = contList[i]->getUpstreamParameterList();
            if (upstreamParameterList.isEmpty()) {
                continue;
            } else {
                if (upstreamParameterList.contains(value)) {
                    containsFlag = true;
                }
            }
        }
    }

    return containsFlag;
}


int RModel::setResponsesThatFlowUpstream()
{
    return 0;
}


int RModel::runAnalysis(RGradientType theGradientType)
{
    // Checking if all pointer properties are filled out
//    int status = checkProperties();
//    if (status < 0) {
//        return -1;
//    }


    int result = 0;
    QList<RResponse *> inputResponseList = getResponseList();

    for (int i = 0; i < inputResponseList.count(); i++) {
        if (!inputResponseList[i]->isAnalyzed()) {
            RModel *theModel = qobject_cast<RModel *>(inputResponseList[i]->getModel());

            if (!theModel) {
                qCritical() << "Error: Response" << inputResponseList[i]->objectName() << "is not associated with any model.";
                return -1;
            }

            if (!isOrchestratingModel) {
                //qCritical() << "Starting analysis at" << theModel->objectName();
                result = theModel->runAnalysis(theGradientType);
            }

#ifdef NETWORKS
           RNetworkModel* theNetworkModel = qobject_cast<RNetworkModel*>(theModel);
           if (theNetworkModel){
               theNetworkModel->getRequests();
           }
#endif
            if (result < 0) {
                qCritical() << "Error in model: Could not run the analysis in the model" << theModel->objectName() << ".";
                return result;
            }
        }
    }


    if (!isAnalyzed) {

        //  START TIMER
        //QElapsedTimer myTimer;
        //myTimer.start();

        // TELL USER WE'RE STARTING
        if (theOutputLevel == RObject::Maximum) {
            //qDebug() << "The analysis in" << this->objectName() << "started";
        }

        // KEEP GUI RESPONSIVE
        QCoreApplication::processEvents();

        // RUN THE MODEL
        result = evaluateModel();

        //if (this->objectName() == QString("theInspectors")){//
        //qCritical() << "Analysis in model" << this->objectName() << "finished after" << myTimer.elapsed()<< "miliseconds";
        //}
    }
    isAnalyzed = true;

    if (result < 0) {
        if (result > -9)
        {
            qCritical() << "Error: Could not evaluate the model" << objectName() << ".";
        }
        if (result == -10)
        {
            qCritical() << "Error: Could not evaluate the DDM in model" << objectName() << ".";
        }
        return result;
    }


    return 0;
}


QList<RConstant *> RModel::getConstantList()
{
    QList<RConstant *> constantList;
    if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
    }
    QList<RParameter *> parameterList = theAllParametersList;
    for (int i = 0; i < parameterList.count(); i++) {
        RConstant *constant = qobject_cast<RConstant *>(parameterList[i]);
        if (constant) {
            constantList.append(constant);
        }
    }
    return constantList;
}

QList<RResponse *> RModel::getResponseList()
{
    QList<RResponse *> responseList;
    if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
    }
    QList<RParameter *> parameterList = theAllParametersList;
    for (int i = 0; i < parameterList.count(); i++) {
        RResponse *response = qobject_cast<RResponse *>(parameterList[i]);
        if (response) {
            responseList.append(response);
        }
    }
    return responseList;
}


void RModel::setResponseAnalyzed(bool analyzed)
{
    QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();
    for (int i = 0; i < outputResponseList.count(); i++) {
        outputResponseList[i]->setAnalyzed(analyzed);
    }
}

QList<RParameter *> RModel::getAllParametersList(bool *ok)
{
    theAllParametersList.clear();

    // Creating a list of parameters to return at the end
    QList<RParameter *> theParameterList;

    // Getting the list of RResponses that are output of this model
    QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();

    // Looping over QProperties
    for (int i = 0; i < this->metaObject()->propertyCount(); i++) {
        // Getting the meta property
        QMetaProperty metaProperty = this->metaObject()->property(i);

        // Getting the tpe of the meta property
        QVariant::Type type = metaProperty.type();


        // Getting the name of the property
        const char * charName = metaProperty.name();


        // Stage1: Populating the theParameterList with individual parameters, which are represented by QProperties
        // Checking if the type of the property is "QObject *"
        if (type == QMetaType::QObjectStar) {
            // Getting the vaue of the property, which is a "QObject *"
            QObject *propertyObject = this->property(charName).value<QObject *>();

            // Down-casting a pointer with the type "RParameter" to the "QObject *"
            RParameter *parameter = qobject_cast<RParameter *>(propertyObject);

            // If the casting succeeds, it mean that the type of this pointer is RParameter. Proceeding to add it to the list.
            if (parameter) {
                // If the parameter is not already in the list ...
                if (!theParameterList.contains(parameter)) {
                    // Down-casting a pointer with the type "RResponse"
                    RResponse *response = qobject_cast<RResponse *>(parameter);

                    // If the type of this parameter is RResponse, it should be checked hat this RResponse is not an OUTPUT to this model.
                    // Thus, if the casting to RResponse succeeds, the "outputResponseList" is searched for this RResponse.
                    // If this RResponse was not found in "outputResponseList", OR this parameter is not an RResponse at all ("response" is NULL), then this RParameter pointer is added to the parmeter list.
                    if (((response) && (!outputResponseList.contains(response))) || (!response)) {
                        theParameterList << parameter;
                    }
                }
            }
            continue;
        }

        // Stage2: Appending the lists of unlimited number of parameters to the "parameterList".
        // The type of the QProperty representing the unlimited list od parameters is QString.
        // So, if the type of the QProperty is QString, it is considered to be added to theParameterList
        // HOWEVER, it should be noted that there are other QProperties such as "type" and "objectName" that are QString and do not contain any parameter list.
        // So, this naming convention must be kept as a rule:
        // If a QProperty of type QString is to reperesent a parameter list, its name should end with the word "List" (case-sensitive).
        if (type == QMetaType::QString) {
            //QString methodName(charName);
            //methodName.replace(0, 1, methodName.at(0).toUpper());
            //methodName = "get" + methodName;
            ////const char * methodCharName = qPrintable(methodName);
            //QByteArray byteArrayName = methodName.toLatin1();
            //const char * methodCharName = byteArrayName.data();
            //RParameterList parameterList;
            //bool ok = QMetaObject::invokeMethod(this, methodCharName, Q_RETURN_ARG(RParameterList, parameterList));

            // Check if the property name contains the word "List"
            if (QString(charName).contains("List")) {

                // Producing a list of RParameters form the value of the QProperty, which is a QString
                QList<QPointer<RParameter> > parameterList = stringToParameterList(this->property(charName).toString());

                // Lopping over the produced list
                for (int j = 0; j < parameterList.count(); j++) {
                    RParameter *parameter = parameterList[j];

                    // If the parameter is not already included in "theParameterList", then add it.
                    if (!theParameterList.contains(parameter)) {
                        theParameterList << parameter;
                    }
                }
            }
            continue;
        }
    }


    // Now, all the QProperties are looped over.

    //    //Get the stuff that was added in RDomain
    //    auto theDomainList = theDomain->getDDMParameterList();
    //    theParameterList.append(theDomainList);

    // Sorting the generated liest
    theDomain->sort(&theParameterList);

    // Assigning to the data member
    theAllParametersList = theParameterList;

    *ok = true;

    // Add the parameters that were auto-created within this model
    for (int i=0; i<theAutoParametersList.size(); i++) {
        theAllParametersList << theAutoParametersList.at(i);
    }


    // Returning the generated list
    return theAllParametersList;
}


void RModel::initiatePtocess(QString workingFilePath)
{
    QString workingPath = RDomain::getAbsoluteFolderPath(workingFilePath);
    bool workingPathIsSet = QDir::setCurrent(workingPath);

    // Instantiating the QProcess
    if (!theProcess) {
        theProcess = new QProcess(this);
    }

    // Checking if the QProcess is not running
    if (theProcess->state() == QProcess::NotRunning) {
        // Setting system environment variables to QProcess
        QStringList environmentList = QProcess::systemEnvironment();
        theProcess->setEnvironment(environmentList);

        // Merging the standard and error channels of the QProcess
        theProcess->setProcessChannelMode(QProcess::MergedChannels);

        // Setting the working directory of the QProcess to the directory of the main input file
        theProcess->setWorkingDirectory(workingPath);

        // Connecting the signal of finished to the slot of onProcessFinished to check if the process has exited normally or crashed
        bool ok = connect(theProcess, SIGNAL(finished(int, QProcess::ExitStatus)), this, SLOT(onProcessFinished(int, QProcess::ExitStatus)));
        //connect(theProcess, SIGNAL(started()), this, SLOT(processStarted()));
    }

    // Connecting the signal "readyReadStandardOutput" of the QProcess to the slot "showOutput", which displays the output in the output pane
    bool ok = connect(theProcess, SIGNAL(readyReadStandardOutput()), this, SLOT(showOutput()));
}

QProcess * RModel::getProcess()
{
    return theProcess;
}

void RModel::showOutput()
{
    QByteArray outputBytes = theProcess->readAllStandardOutput();
    if (theOutputLevel >= RObject::Medium) {
        QStringList lines = QString(outputBytes).split("\n");
        foreach (QString line, lines) {
            if (line.length() > 0) {
                qDebug() << qPrintable(line);
            }
        }
    }

    //// The follwoing lines are required in the case that the external software should not be closed at the end of the analysis. They are needed to determine that the external software is done with the analysis.
    if (processFinishedAnalyzing) {
        if (outputBytes.contains(finishString)) {
            processFinishedAnalyzing = false;

            emit processFinished();

            // Disconnect the readyReadStandardOutput from this method, because from now on, we need to read responses and we don't want the results of the commands of the RCommandResponse to be shown in the output pane. The signal will be reconnected in the initiateProcess the next time the evaluateFunction is called
            disconnect(theProcess, SIGNAL(readyReadStandardOutput()), this, SLOT(showOutput()));
        }
    }
}

void RModel::eventLoop(bool continuousProcess)
{		
    bool ok;


    // This is the event loop of waiting for the analysis in the external application to be finished
    QEventLoop runEventLoop;

    ok = connect(theProcess, SIGNAL(finished(int, QProcess::ExitStatus)), &runEventLoop, SLOT(quit()));
    if (continuousProcess) {
        ok = connect(this, SIGNAL(processFinished()), &runEventLoop, SLOT(quit()));
    }

    //QTimer timer;
    //connect(&timer, SIGNAL(timeout()), &runEventLoop, SLOT(quit()));
    //timer.start(7000);

    if (processFinishedAnalyzing) {
        runEventLoop.exec();
    }

    //bool active = timer.isActive();
    //if (!active) {
    //	qCritical() << "Warning: Rt has waited for 7 seconds, but the analysis of the external software is not done yet. Terminating the analysis";
    //}

    ok = disconnect(theProcess, SIGNAL(finished(int, QProcess::ExitStatus)), &runEventLoop, SLOT(quit()));
    if (continuousProcess) {
        ok = disconnect(this, SIGNAL(processFinished()), &runEventLoop, SLOT(quit()));
    }
}

void RModel::onProcessFinished(int exitCode, QProcess::ExitStatus exitStatus)
{
    if (exitStatus == QProcess::CrashExit) {
        qCritical() << "Warning: The external application in the model" << this->objectName() << "has crashed.";
    }
}

void RModel::clearNullPointers(QList<QPointer<RParameter> > *passdedParameterList)
{
    for (int i = 0; i < passdedParameterList->count(); i++) {
        if (!passdedParameterList->value(i)) {
            passdedParameterList->removeAt(i);
            i--;
        }
    }
}


void RModel::reset()
{

}

void RModel::updateHistoryVariables()
{

}

void RModel::resetHistoryVariables()
{

}

int RModel::resetTime()
{
    return 0;
}


