#ifndef RDomain_H
#define RDomain_H

#include <functional>
#include <algorithm>
#include "RTime.h"
#include "RObject.h"
#include <unordered_map>


class RModel;
class RParameter;
class RResponse;
class RTime;

extern RTime* theCurrentTime;

struct RGetObjects
{
public:

    template <typename From, typename To>
    struct static_caster
    {
        To* operator()(From* p) {return static_cast<To*>(p);}
    };

    template <typename T>
    void registerClasstoGet(std::string const &type)
    {
        getObjectRegistry()[type] = [](QObject* parent){

            std::list<RObject*> returnList;

            std::list<T*> list = parent->findChildren<T*>().toStdList();

            //Since the list is in terms of the derived class, we need to cast to parent RObject
            std::transform(list.begin(), list.end(), std::back_inserter(returnList), static_caster<T,RObject>());

            return returnList;
        };
    }


   std::list<RObject*> getObjectList(std::string const &type, QObject* parent)
   {
       std::list<RObject*> list;

       auto it = getObjectRegistry().find(type);
       if (it == getObjectRegistry().end())
       {
           //qCritical()<<"Could not find the class"<<QString::fromStdString(type)<<"in the RDomain Registry";
           //Return an empty list
           return list;
       }

       list = it->second(parent);

       return list;
   }

private:

   //Map to hold the get object class type, templated alias; cannot template a typedef
   using getObjectTypeMap = std::unordered_map<std::string, std::function<std::list<RObject*>(QObject*)>> ;
   static getObjectTypeMap & getObjectRegistry()
   {
       static getObjectTypeMap mapVal;
       return mapVal;
   }

};

//Factory class using variadic templates and lambda functions to keep it reuseable and general
template <typename T>
class RFactory
{
public:

    RGetObjects getObjects; //Specific for RDomain

    template <typename... TDerived>

    static  T* instantiate(std::string const &type, TDerived&&...args)
    //T* instantiate(std::string const &type, TDerived&&...args)
    {
        auto it = registry().find(type);
        if (it == registry().end())
        {
            //qCritical()<<"Could not find the class"<<QString::fromStdString(type)<<"in the RDomain Registry";
            return 0;
        }

        return it->second(args...);
    }

    //Function to register the class
    template <typename TDerived>
    int registerClass(std::string type)
    {
        //Can check for if class is a base, but only if it directly inherits from it
        //         if(std::is_base_of<T, TDerived>::value)
        //         {
        //             qCritical()<<"RDomain doesn't accept this type because doesn't derive from base class";
        //             return -1;
        //         }

         registry()[type] = [](QObject* parent, QString name){return new TDerived(parent, name);};

         getObjects.registerClasstoGet<TDerived>(type); //Specific for RDomain

         return 0;
    }

private:

    //Map to hold the create object class types
    typedef std::unordered_map<std::string, std::function<T*(QObject*, QString)>> registryMap;

    static registryMap & registry()
    {
        static registryMap mapVal;
        return mapVal;
    }
};



class RDomain : public RObject
{
	Q_OBJECT

public:
	RDomain(QObject *parent, QString name);
	~RDomain();

	// Creates a new RObject given its object name, and class name
	int createObject(QString name, QString passedClassName, bool isAutoGenerated = true);

	// Deletes an RObject given its name
	int deleteObject(QString name);

	// Renames an RObject after checking if the name complies with the naming rules
	int renameObject(QObject *passedObject, QString name);

	// Returns a pointer to the last instantiated RObject 
	QObject *getLastAddedObject() const;

	// Checks if a given object name compies with the naming rules
	int nameIsValid(QString name, bool checkForDuplicate = true);

	// Sets a flag that indicates if Rt is currently in the process of opening an input file
	void setInputFileBeingOpened(bool value);

	// Returns a list of RObject pointer that are derived from the passed class name
	QObjectList getObjectList(QString passedClassName);

	// Returns a string-list of object names from the passed list of object pointers
	QStringList getStringList(QObjectList objectList);

	// Returns the value of a meta-property named "propertyName" for the passed object as a string
	QString getProperty(const QObject *passedObject, QString propertyName) const;

	// Sets the value of a meta-property named "propertyName" for the passed object to the passed value
	int setProperty(QObject *passedObject, QString propertyName, QString propertyValue);

	// Retunrs the current file path of Rt
	QString getCurrentFilePath() const;

	// Sets the current file path of Rt to the passed value
	void setCurrentFilePath(QString value);

    // Sorts the passed QObject list by their object names
	int sort(QObjectList *passedList);

	// Overload method that sorts the passed model list by their object names
	int sort(QList<RModel *> *passedList);

	// Overload method that sorts the passed parameter list by their object names
	int sort(QList<RParameter *> *passedList);

	// Overload method that sorts the passed response list by their object names
	int sort(QList<RResponse *> *passedList);

	// Returns a list of possible values for the passed property that the user can choose from
	QStringList getPropertyStringList(QString propertyName);

	// Prints the elements of the passed matrix to the output pane, or to the passed outputFile if any
    void print(QVector< QVector<double> > *matrix, QString outputFile = QString());

	// Overloaded method that print the elements of the passed vector to the output pane, or to the passed outputFile if any
    void print(QVector<double> *vector, QString outputFile = QString());

	// Reads the elements of the passed matrix from the inputFile
    int readMatrixFromFile(QVector< QVector<double> > *matrix, QString inputFile);
	
	// Overloaded method that reads the elements of the passed matrix from the inputFile
    int readVectorFromFile(QVector<double> *vector, QString inputFile);

	// Static method that returns the sub-branches of a base-class to be shown in the object pane tree
    static QStringList createObjectTreeBranches(QString baseClassType);

    // Static method that returns the name of all dynamic meta-properties in any class in Rt
	static QStringList getDynamicPropertyList();

	// Static method that returns the absolute path to the folder that contains the passed file
	static QString getAbsoluteFolderPath(QString filePath);

	// Static method that returns the file name of the passed file
	static QString getFileName(QString filePath);

	// Static method that coverts the passed string to a file path, by removing the double-quotes from the string
	static QString stringToFilePath(QString string);

    void clearAnalyzedFlags();

    int checkAllProperties();

    void addToDDMList(RParameter* theParameter);

    QList<RParameter*> getDDMParameterList();

    void updateObjectTree();

private:

    //Define instance of factory class to create classes dynamically
    RFactory<RObject> factory;

	// pointer to the last instantiated rObject
	QObject *theLastAddedObject;

    // Data member that stores the current file path of Rt
    QString theCurrentFilePath;

	// Flag that indicates if Rt is currently in the process of opening an input file
	bool isInputFileBeingOpened;

    void registerHeadersAsClasses();

};




#endif // RDomain_H
